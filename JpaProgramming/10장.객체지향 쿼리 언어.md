## 객체지향 쿼리 개요

### JPA가 공식 지원하는 기능

1. JPQL
    - 테이블이 아닌 엔티티 객체를 대상으로 검색
    - SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음
2. Criteria 쿼리
    - JPQL을 편하게 작성하도록 도와주는 API와 빌더 클래스
    - 컴파일 시점 오류 발견 가능
    - IDE 자동완성 지원
    - 동적 쿼리 작성 용이
3. 네이티브 SQL
    - JPA에서 JPQL 대신 직접 SQL 사용 가능

### JPA 비공식 지원

1. QueryDSL
    - JPQL 빌더 역할
    - Criteria보다 단순하고 사용하기 쉬움
    - 비표준 오픈소스 프레임워크
2. JDBC 직접 사용, MyBatis 연동
    - 필요한 경우 JDBC 직접 사용 가능
    - JPA와 함께 사용시 영속성 컨텍스트 고려 필요

## 2. JPQL 상세

### 기본 특징

- 객체지향 쿼리 언어로 엔티티 객체를 대상으로 쿼리
- SQL을 추상화하여 데이터베이스에 독립적
- 대소문자 구분 (엔티티와 속성은 대소문자 구분)
- 엔티티 이름 사용 (@Entity의 name 속성값)
- 별칭 필수 사용

### 페치 조인 (Fetch Join)

- SQL 조인의 종류가 아닌 JPQL의 성능 최적화 기능
- 연관된 엔티티나 컬렉션을 한 번에 조회
- 문법: `join fetch`

### 페치 조인의 특징과 한계

1. 특징
    - SQL 한 번으로 연관 엔티티 함께 조회 가능
    - 지연 로딩 발생하지 않음
    - 준영속 상태에서도 객체 그래프 탐색 가능
2. 한계
    - 페치 조인 대상에 별칭 사용 불가
    - 둘 이상의 컬렉션 페치 불가
    - 컬렉션 페치 조인시 페이징 API 사용 불가

### Named 쿼리: 정적 쿼리

- 미리 정의한 쿼리에 이름을 부여해서 사용
- 애플리케이션 로딩 시점에 검증 가능
- 정적인 쿼리만 가능

```java
java
Copy
@Entity
@NamedQuery(
    name = "Member.findByUsername",
    query = "select m from Member m where m.username = :username")
public class Member {
    ...
}

```

## 3. Criteria 쿼리

- JPQL을 자바 코드로 작성하도록 도와주는 빌더 API
- 장점:
    - 컴파일 시점 오류 체크
    - IDE 자동완성 지원
    - 동적 쿼리 작성 용이
- 단점: 복잡하고 가독성이 떨어짐

## 4. QueryDSL

- 장점:
    - 코드 기반의 쿼리 작성
    - 단순하고 사용하기 쉬움
    - 동적 쿼리 작성 편리
- 주요 기능:
    - 검색조건 쿼리
    - 페이징과 정렬
    - 서브쿼리
    - 조인
    - 프로젝션과 결과 매핑

## 5. 네이티브 SQL

- 특정 데이터베이스에 종속적인 기능 사용시 필요
- JPQL로 해결할 수 없는 특별한 기능 사용시 활용
    - 특정 DB만의 함수
    - 인라인 뷰
    - UNION, INTERSECT
    - 스토어드 프로시저
- 단점: 특정 데이터베이스에 종속적

## 6. 벌크 연산

- 여러 엔티티를 한 번에 수정/삭제하는 기능
- 주의사항:
    - 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
    - 벌크 연산 수행 후 영속성 컨텍스트와 DB 데이터 불일치 가능성

### 해결방안

1. `em.refresh()` 사용
2. 벌크 연산을 가장 먼저 실행
3. 벌크 연산 후 영속성 컨텍스트 초기화

## 7. 영속성 컨텍스트와 JPQL

- JPQL로 조회한 엔티티가 영속성 컨텍스트에 이미 있는 경우:
    - 데이터베이스에서 조회한 결과는 버림
    - 영속성 컨텍스트의 기존 엔티티를 반환
- 영속성 컨텍스트는 영속 상태 엔티티의 동일성을 보장

### JPQL과 플러시 모드

- JPQL 실행 전 영속성 컨텍스트의 내용을 DB에 반영해야 함
- 해결방법:
    - `em.flush()` 수동 호출
    - `setFlushMode()`로 플러시 모드를 AUTO로 변경

## 8. 정리

1. JPQL을 기본으로 사용
2. 동적 쿼리는 QueryDSL 활용
3. 네이티브 SQL은 최후의 수단으로 사용
4. 벌크 연산 사용시 영속성 컨텍스트 고려
5. 글로벌 로딩 전략은 지연 로딩으로 설정
6. 성능 최적화가 필요한 곳에만 페치 조인 적용