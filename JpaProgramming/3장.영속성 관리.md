# 영속성 관리

## EntityManager

**엔티티 매니저 팩토리** 

- 엔티티 매니저를 만드는 공장과 같음
- 만드는 비용이 상당히 큼
- 한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있음
- 여러 스레드가 동시에 접근해도 안전하기 때문에 스레드 간 공유 가능

**엔티티 매니저**

- 엔티티 매니저 팩토리에서 엔티티 매니저를 생성하는 비용은 거의 들지 않음
- 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 가 공유 X

## 영속성 컨텍스트

**영속성 컨텍스트** 

- 엔티티를 영구 저장하는 환경
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 메니저는 영속성 컨테스트에 엔티티를 보관하고 관리

```java
em.persist(member);
```

persist() : 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장

### 엔티티의 생명주기

엔티티에는 4가지의 상태가 존재

**비영속(new/transient)** : 영속성 컨텍스트와 전혀 관계가 없는 상태

- 데이터베이스와 관련이없는 순수한 객체상태

**영속(managed)** : 영속성 컨텍스트에 저장된 상태

- 영속성 컨텍스트가 관리하는 엔티티의 상태를 영속 상태라고 함
- persist() 한 상태 혹은 find()로 조회한 엔티티 상태

**준영속(detached)** : 영속성 컨텍스트에 저장되었다가 분리된 상태

- 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속선 컨텍스트가 관리하지 않는 상태
- 다음 메서드를 호출하면 영속 상태의 엔티티가 준영속 상태가 됨
    - em.detach()
    - em.close() : 영속성 컨텍스트를 닫음
    - em.clear() : 영속성 컨테스트를 초기화

**삭제(removed)** : 삭제된 상태

- remove()로 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/79e1cf07-a08e-4127-afe2-5ef212088702/8046e197-2114-4708-82c9-f1dd5b26fc5b/image.png)

## 영속성 컨텍스트의 특징

- 영속 상태는 식별자 값이 반드시 있어야 한다
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이를 **플러시(flush)**라고 함
- 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다
    - 1차캐시
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지
    - 지연 로딩

### **엔티티 조회**

### 1차 캐시란?

- `em.persist(엔티티)` 메서드를 호출하면 엔티티가 영속성 컨텍스트의 1차 캐시에 저장된다 이 1차 캐시는 영속성 컨텍스트의 내부 메모리일 뿐, 아직 데이터베이스에 저장된 상태는 아니다 즉, 애플리케이션 메모리에 임시로 저장된 상태라는 뜻이다

### 1차 캐시의 Key 값

- 1차 캐시는 엔티티의 **식별자 값(id)** 을 Key로 사용해 엔티티를 관리한다
- `em.find(엔티티, key값)` 메서드를 사용하면 1차 캐시에서 엔티티를 조회할 수 있다

### 조회 과정

1. `em.find`로 엔티티를 조회할 때, 우선적으로 1차 캐시에서 식별자 값으로 찾는다
2. **1차 캐시에 엔티티가 존재하면** 데이터베이스를 조회하지 않고 바로 메모리에 있는 엔티티를 반환한다
3. **1차 캐시에 없으면** 데이터베이스에서 조회한 후, 해당 엔티티를 영속 상태로 만들어 1차 캐시에 저장하고 반환한다

### 1차 캐시를 통한 성능 이점

- 메모리는 데이터베이스 디스크보다 훨씬 빠르다
- 1차 캐시에서 데이터를 조회하면 데이터베이스와의 통신 없이 메모리에서 데이터를 읽기 때문에 조회 성능이 더 좋아진다

### 플러시(Flush)와 SQL 실행

- **플러시가 호출될 때** 또는 **1차 캐시에 엔티티가 없을 때** 실제 데이터베이스에 SQL 쿼리가 전송된다
- 트랜잭션이 커밋되지 않았거나, 수동으로 플러시를 호출하지 않은 경우에는 플러시가 발생하지 않으므로 데이터베이스에 반영되지 않는다
- 따라서 트랜잭션 안에서 1차 캐시에 있는 엔티티를 여러 번 조회해도 데이터베이스와 통신하지 않으므로 성능상 이점을 누릴 수 있다

### 영속 엔티티의 동일성 보장

```java
Member member1 = jpa.find(Member.class, 1L);
Member mebmer2 = jpa.find(Member.class, 1L);
```

member1 과 member2는 1차 캐시에 있는 같은 엔티티 인스턴스이고 , a==b는 참이 됨

**영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장**

### 엔티티 등록

1. `EntityManager`를 생성하고, `EntityTransaction`을 얻는다
2. 트랜잭션을 시작한 후(`transaction.begin()`), `em.persist(엔티티)`로 엔티티를 1차 캐시에 저장한다
    - 이때 INSERT SQL은 데이터베이스에 보내지 않고, 영속성 컨텍스트의 쓰기 지연 저장소에 모아둔다
3. 트랜잭션을 커밋하면(`transaction.commit()`) 모아둔 INSERT SQL이 한꺼번에 데이터베이스로 전송된다
    - 이를 **트랜잭션을 지원하는 쓰기 지연(transactional write-behind)** 라고 하며, 성능 이점을 제공한다

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/79e1cf07-a08e-4127-afe2-5ef212088702/47192a12-b79b-4962-9d5a-f436461a4cb5/image.png)

### 엔티티 수정

1. `em.persist()`로 엔티티를 저장하고 트랜잭션이 커밋되기 전까지, 쓰기 지연 저장소에 SQL이 모인다
2. 매번 엔티티를 수정할 때마다 UPDATE SQL을 쌓아두는 대신, **변경 감지(dirty checking)** 를 사용한다
    - JPA는 엔티티를 처음 영속성 컨텍스트에 보관할 때 상태를 복사한 **스냅샷**을 생성해둔다
3. 트랜잭션 커밋 시 플러시가 호출되고, 엔티티와 스냅샷을 비교하여 변경된 엔티티를 찾는다
4. 변경된 엔티티가 있다면 UPDATE SQL을 생성하여 쓰기 지연 저장소에 보관하고, DB에 전송한다
5. 변경 감지는 **영속 상태**의 엔티티에만 적용되며, 비영속 또는 준영속 상태의 엔티티는 반영되지 않는다
    - 기본적으로 모든 필드를 업데이트하나, 특정 필드만 업데이트하려면 `@DynamicUpdate`를 사용한다
    - `@DynamicUpdate`는 필드 수가 많거나 최적화가 필요한 경우에 선택적으로 사용한다

### 엔티티 삭제

1. `em.remove(엔티티)` 메서드를 사용하여 엔티티를 삭제할 수 있다
    - 삭제할 엔티티는 먼저 조회(`em.find`)한 후 `remove` 메서드를 호출한다
2. 삭제 역시 등록과 비슷하게, 즉시 DB에 반영되지 않고 쓰기 지연 저장소에 DELETE SQL이 쌓인다
3. 트랜잭션 커밋 시 DELETE SQL이 데이터베이스에 전송되어 실제로 삭제된다
4. `remove()` 호출 후, 영속성 컨텍스트에서 해당 엔티티는 더 이상 관리되지 않는다
    - 삭제된 엔티티는 가비지 컬렉션으로 수거되도록 내버려 두는 것이 좋다

### 플러시 (flush)

플러시는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 과정이다. 플러시가 실행되면 다음과 같은 일이 일어난다

1. 변경 감지(dirty check)로 영속성 컨텍스트의 모든 엔티티를 스냅샷과 비교해 수정된 엔티티를 찾고, 수정된 엔티티에 대해 수정 쿼리를 생성해 쓰기 지연 SQL 저장소에 등록한다
2. 쓰기 지연 SQL 저장소에 있는 쿼리들을 DB에 전송한다

### 영속성 컨텍스트를 플러시하는 방법 3가지

1. `em.flush()` 직접 호출하기: 테스트나 다른 프레임워크를 사용할 때를 제외하고 거의 사용하지 않는다
2. 트랜잭션 커밋: 커밋 시 플러시가 자동으로 호출된다. 트랜잭션만 커밋하고 플러시를 실행하지 않으면 쓰기 지연 SQL 저장소에 있는 쿼리가 DB에 반영되지 않는다
3. JPQL 쿼리 실행 시 자동 호출: JPQL 쿼리를 실행할 때 자동으로 플러시가 호출된다

### 플러시 모드 옵션

엔티티 매니저에서 플러시 모드를 직접 지정할 수 있다

- `FlushModeType.AUTO` (기본값): 커밋이나 쿼리를 실행할 때 플러시된다
- `FlushModeType.COMMIT`: 커밋할 때만 플러시된다

플러시는 영속성 컨텍스트에 보관된 엔티티를 지우는 것이 아니라, 변경 내용을 DB에 동기화하는 것이다

---

### 준영속 (Detached)

준영속은 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 상태다. 준영속 상태의 엔티티는 영속성 컨텍스트의 기능을 사용할 수 없다

### 영속 상태의 엔티티를 준영속 상태로 만드는 방법 3가지

1. `em.detach(entity)`: 특정 엔티티를 준영속 상태로 전환
2. `em.clear()`: 영속성 컨텍스트 초기화로 모든 엔티티를 준영속 상태로 만든다
3. `em.close()`: 영속성 컨텍스트 종료로 관리하던 모든 영속 상태 엔티티를 준영속 상태로 만든다

---

### 준영속 상태의 특징

- 영속성 컨텍스트의 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 등의 기능을 사용할 수 없다
- 식별자 값(PK, ID)은 가지고 있다. 비영속 상태와 달리 한 번 영속 상태였기 때문에 식별자 값은 유지된다
- 지연 로딩을 할 수 없다. 영속성 컨텍스트에 없으므로 지연 로딩 시 문제가 발생한다

---

### 병합 (Merge)

병합은 준영속 상태의 엔티티를 다시 영속 상태로 변경하는 방법이다. `merge()` 메서드를 사용해 실행한다

```java
Member mergeMmber = em.merge(member); // member는 비영속 또는 준영속 상태
```

- 병합은 준영속 상태와 비영속 상태를 구분하지 않고 실행된다. 식별자 값으로 엔티티를 조회할 수 있으면 조회해서 병합하고, 조회할 수 없으면 새로 생성해 병합한다
- 병합은 `save` 또는 `update` 기능을 수행한다